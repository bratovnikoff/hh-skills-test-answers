# JavaScript — средний уровень

> Q1. Каким будет результат выполнения следующего кода?
>
> ```js
> const scores = [3, 6, 9];
> const doubled = scores.map((n) => n * 2);
> console.log(doubled[1] - scores[0]);
> ```

- [ ] `12`
- [ ] `3`
- [ ] `6`
- [x] `9`
- [ ] `0`

> Q2. Какое из утверждений о cookies является НЕВЕРНЫМ?

- [ ] Cookies могут быть доступны как клиенту, так и серверу
- [ ] Cookies имеют ограничение по размеру
- [ ] Cookies могут использоваться для хранения сессионных данных
- [x] Cookies могут содержать JavaScript-функции
- [ ] Cookies могут иметь дату истечения срока действия

> Q3. Какое из ниже приведённых выражений вернёт `false` в результате вычисления?

- [ ] `10 % 3 === 1`
- [x] `(1 === true) === true`
- [ ] `3 < 5 && 5 < 10 === true`
- [ ] `(3 < 5 && 5 < 10) === true`
- [ ] `2 + 2 * 2 === 6`

> Q4. Каким будет результат выполнения данного кода?
>
> ```js
> let count = 5;
> count = ++count + 6;
> console.log(count);
> ```

- [x] `12`
- [ ] `undefined`
- [ ] `11`
- [ ] `NaN`
- [ ] `10`

> Q5. Вам требуется обрабатывать последовательность элементов, у которых есть индексы, и выполнять действия, учитывающие номер каждого элемента. Какую конструкцию рационально выбрать?

- [ ] `do-while`
- [ ] `switch-case`
- [ ] `while`
- [x] `for`
- [ ] `if-else`

> Q6. При объявлении анонимной функции через `let` внутри блока кода `{ }`, что можно сказать про её доступность?

- [ ] Продолжает действовать даже после выхода из блока
- [ ] Она сохраняется во всех вложенных функциях
- [x] Используется только в рамках текущего блока
- [ ] Автоматически становится глобально доступной
- [ ] Присваивается объекту `this`

> Q7. Необходимо объединить два массива объектов `arrA` и `arrB` в один массив, добавив элементы второго к первому. Какой способ это сделает?
>
> ```js
> const arrA = [{ id: 1 }, { id: 2 }];
> const arrB = [{ id: 3 }, { id: 4 }];
> function mergeArrays(a, b) {
>   return ___;
> }
> console.log(mergeArrays(arrA, arrB));
> ```

- [ ] `Object.assign(a, b)`
- [ ] `a.concat(b).reduce((acc, el) => acc + el, [])`
- [x] `[ ...a, ...b ]`
- [ ] `a.map(item => b.push(item))`
- [ ] `b.forEach(el => a[el] = el)`

> Q8. Вы разрабатываете внутреннюю CRM-систему для крупной компании. Ваша задача — создать модуль хранения информации о сотрудниках для последующей аналитики и отчётов.
>
> Необходимые функциональности:
>
> — Создание хранилища, где фиксируются ФИО, телефон, отдел, должность, дата приема на работу
>
> — Возможность добавления новых сотрудников и обновления их информации
>
> — Фильтрация сотрудников по отделам и должности, подсчет общего количества
>
> Проанализируйте техническое задание. Как вы организуете структуру данных для хранения информации о сотрудниках?

- [ ] Создать отдельный объект только для дат приема, а всё остальное вынести в глобальную переменную
- [ ] Сохранить всю информацию в одной строке через разделитель и каждый раз парсить её
- [x] Использовать массив объектов, где каждый сотрудник — один объект (ФИО, телефон, отдел, должность, дата)
- [ ] Сделать объект, где каждое поле — это массив со всеми ФИО, всеми телефонами и т.д
- [ ] Превратить каждую строку (ФИО, телефон, отдел, должность, дата) в один общий массив

> Q9. Какую концепцию наследования в JavaScript демонстрирует код ниже?
>
> ```js
> function Person(name) {
>   this.name = name
> }
> erson.prototype.sayHello = > function() {
>   return 'Hi, ' + this.name
> }
> const user = new Person('Lena')
> ```

- [ ] Прямое наследование
- [ ] Прототипное копирование
- [x] Функция-конструктор с прототипом
- [ ] Делегирование через классы
- [ ] Прототип как объект

> Q10. Чем отличается прототипное наследование от классического наследования?

- [ ] Прототипное наследование не может быть переопределено
- [ ] Прототипное наследование требует создания экземпляров через new
- [x] Прототипное наследование основано на делегировании через ссылки между объектами
- [ ] Прототипное наследование работает только с примитивами
- [ ] Прототипное наследование использует абстрактные классы для наследования

> Q11. Что произойдет при выполнении кода?
>
> ```js
> function createCounter() {
>   let count = 0;
>   return {
>     increment() {
>       count++;
>       return count;
>     },
>   };
> }
> const counter = createCounter();
> console.log(counter.increment());
> ```

- [x] Метод `increment` использует замыкание для доступа к `count` и увеличивает его
- [ ] Создается глобальная переменная `count` и метод `increment` в `counter`, который увеличивает `count`
- [ ] Каждый вызов `increment` возвращает `1`, так как заново создается `count` и увеличивается на `1`
- [ ] `count` становится недоступным после первой итерации
- [ ] Функция `createCounter` ничего не возвращает

> Q12. Когда целесообразно применять `async/await`?
> При последовательной обработке шагов, каждый из которых зависит от результата предыдущего

- [x] При последовательной обработке шагов, каждый из которых зависит от результата предыдущего
- [ ] При описании функций, не содержащих операций с побочными эффектами
- [ ] При реализации цепочки преобразований без промежуточных переменных
- [ ] При объявлении функций, содержащих вложенные циклы без асинхронных вызовов
- [ ] При создании логики, основанной на генераторах и итерируемых объектах
